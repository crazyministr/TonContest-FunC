{-

TASK 5 - SHARED WALLET.

The aim of two owner wallet is to create smart-contract which send messages then and only then both owners (represented by public keys) authorized it.

TL-B schema of external message body accepted by wallet is as follows:
```
request#_ valid_until:uint32 mode:uint8 msg_to_send:^Cell = Request;
mdg_body#_ public_key:uint256 signature:(512 * Bit) request:^Request = MsgBody;
```

Where `signature` signs `Request` cell with some private key and `public_key` is corresponding public key.

`msg_to_send` is fully formed message which is ready to be accepted by `send_raw_message()`.

Any errors related to the incorrect `msg_to_send` may be ignored (in other words if something goes wrong due to owner's malformed message, it is owner's problem).

When wallet receive request signed by one owner it should store it in storage.

When wallet receives the same request signed by another owner it should process request, that means send `msg_to_send` with `mode` in the same transaction it got second signature.

If request is signed not by owner, contains incorrect signature or current time is higher than `valid_until`, request should be ignored (message should not be accepted).

If the same request (regardless approved by one or both owners) is sent the second time it should be ignored.

It is acceptable to ignore requests which are valid for more than 1 minute as well as not accept more than 10 requests per minute.

Before running tests, storage for contract will be generated by `pack_data` with providing two public keys. Thus participants may intoduce their own storage layout.

-}

_ load_data() inline_ref {
    var ds = begin_parse(get_data());
    var res = (
	    ds~load_uint(256),
	    ds~load_uint(256),
	    ds~load_dict()
	);
    ds.end_parse();
    return res;
}

_ pack_state(int public_key1, int public_key2, cell pending_queries) inline_ref {
	return begin_cell()
		.store_uint(public_key1, 256)
		.store_uint(public_key2, 256)
		.store_dict(pending_queries)
	.end_cell();
}

cell update_pending_queries(cell pending_queries, int key, int signed_by, cell req) inline_ref {
	pending_queries~udict_set_builder(
		256, key,
		begin_cell()
			.store_uint(signed_by, 2)
			.store_ref(req)
	);
	return pending_queries;
}

;; testable
cell pack_data(int public_key1, int public_key2) method_id {
	;; pending_queries: {req_hash: Cell(int signed_by, ^Cell request)}
	;; signed_by: 2bits flag
	cell pending_queries = new_dict();

	set_data(pack_state(
		public_key1,
		public_key2,
		pending_queries
	));
	return get_data();
}

;; testable
() recv_external (slice in_msg_body) impure {
	if (slice_empty?(in_msg_body)) {
		return ();
	}

	var (public_key1, public_key2, pending_queries) = load_data();

	int public_key = in_msg_body~load_uint(256);
	slice signature = in_msg_body~load_bits(512);

	;; parse request
	cell req = in_msg_body~load_ref();
	slice req_slice = req.begin_parse();
	int req_hash = slice_hash(req_slice);

	int owner_id = -1;
	if (public_key == public_key1) {
		owner_id = 0;
	}
	if (public_key == public_key2) {
		owner_id = 1;
	}
	throw_if(101, owner_id == -1);  ;; request not from owner
	throw_unless(102, check_signature(req_hash, signature, public_key));  ;; invalid signature

	int valid_until = req_slice~load_uint(32);
	throw_if(103, valid_until < now());

	(slice query, var found?) = pending_queries.udict_get?(256, req_hash);
	ifnot (found?) {
		pending_queries = update_pending_queries(pending_queries, req_hash, 1 << owner_id, req);
		set_data(pack_state(public_key1, public_key2, pending_queries));
		return ();
	}
	(int signed_by, cell req) = (query~load_uint(2), query~load_ref());
	if ((signed_by == 3) | (signed_by | (1 << owner_id) == signed_by)) {  ;; already processed OR same owner sign
		return ();  ;; ignore
	}

	signed_by = signed_by | (1 << owner_id);
	pending_queries = update_pending_queries(pending_queries, req_hash, signed_by, req);
	set_data(pack_state(public_key1, public_key2, pending_queries));

	if (signed_by == 3) {  ;; both owners has been signed
		;; valid_until has been checked above
		int mode = req_slice~load_uint(8);
		cell msg_to_send = req_slice~load_ref();

		accept_message();
		send_raw_message(msg_to_send, mode);
	}
}

() recv_internal(slice in_msg) impure {
  ;; do nothing for internal messages
}
